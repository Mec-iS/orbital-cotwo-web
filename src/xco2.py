# coding=utf-8
"""
Xco2 class. Main table/class/mapper of the application.

Create database table and bind to persistence layer (PostGRE/PostGIS)
<https://www.python.org/dev/peps/pep-0249/>

 Before running this script INSTALL and CREATE THE DATABASES (gis and test)
 as explained in README.md

"""

from sqlalchemy import orm
from sqlalchemy import Column, Integer, DateTime
from sqlalchemy.dialects.postgresql import JSON, DOUBLE_PRECISION
from sqlalchemy import UniqueConstraint
from geoalchemy2 import Geography, Geometry
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.exc import IntegrityError

__author__ = 'Lorenzo'

from config.config import DATABASES

Base = declarative_base()


class Xco2(Base):
    """
    Main table's model
    """
    #
    # Table definition
    # ------------------------------------------------------------------------
    __tablename__ = 't_co2'

    id = Column('id', Integer, primary_key=True)
    xco2 = Column('xco2', DOUBLE_PRECISION(precision=11), nullable=False)
    timestamp = Column('timestamp', DateTime, nullable=False)
    # use a geometry with pixels (for Web maps)
    geometry = Column(
        'geometry',
        Geometry('POINT', srid=3857, spatial_index=True),
        nullable=False
    )
    # #todo: implement an 'archive' mechanism for newer relevations
    # #todo: when this constraint is violated, record should be archived
    # #todo: and the new record with the new relevation should be stored
    __table_args__ = (
        UniqueConstraint('timestamp', 'geometry', name='uix_t_co2_timestp_coords'),
    )

    #
    # Constructor
    # ------------------------------------------------------------------------
    def __init__(self, xco2, timestamp, longitude, latitude):
        self.xco2 = xco2
        self.timestamp = timestamp
        self.latitude = latitude
        self.longitude = longitude

    def store_xco2(self):
        """
        Main function to the database when storing Xco2 data.

        INSERT procedure is as follow:
            - insert point > belong the point to any known area?
            - if Y > INSERT point
            - if N > create area with center=point using shape_aoi()

        At database initialization, this method is called to populate both
         the Xco2 and the Areas tables following the pop-above algorithm.

        Store a Xco2 datum and store or update its related Area of Interest.

        :return tuple: (pkey_xco2, pkey_area, )
        """
        from src.spatial import spatial
        from src.dbproxy import dbProxy
        geometry = spatial.shape_geometry(self.longitude, self.latitude)
        ins = Xco2.__table__.insert().values(
            xco2=self.xco2,
            timestamp=self.timestamp,
            geometry=geometry
        )
        try:
            result = dbProxy.alchemy.execute(ins)
            aoi = Areas.store_area(geometry, self.xco2)
        except (IntegrityError, Exception) as e:
            # #todo:
            # integrity error happens when a datum is updated or two data are
            # are rounded to the same coordinates (Postgis maximum tolerance is -xxx.yyy)
            # compare dates, if record is more recent store it and archive the older one;
            # in the latter case, just pass
            # #### raise e
            # at the moment pass
            pass
            return None, None

        return result.inserted_primary_key, aoi.pk

    def __repr__(self):
        return 'Point {coordinates!r}'.format(
            coordinates=repr(self.geometry)
        )

    def __str__(self):
        return 'Point {coordinates!s} has Xco2 level at {xco2!s}'.format(
            coordinates=str(self.geometry),
            xco2=self.xco2
        )

    @property
    def named_tuple(self):
        from collections import namedtuple
        Xco2Named = namedtuple('Xco2Named', ['id', 'xco2', 'timestamp', 'geometry'])
        return Xco2Named(
            id=self.id,
            xco2=self.xco2,
            timestamp=self.timestamp,
            geometry=self.geometry
        )


class Areas(Base):
    """
    Lookup table's model.

    It stores pre-cached squared POLYGONs (Area of Interest, generated by picking
    random points as centers and a side of approximately 150 kms) mapped to
    GEOJSONs with data about points contained in these same polygons.

    see `src.areasOps` module for further documentation.
    """
    #
    # Table definition
    # ------------------------------------------------------------------------
    __tablename__ = 't_areas'

    id = Column('id', Integer, primary_key=True)
    # area of interest, a polygon (square)
    aoi = Column(
        'aoi',
        Geometry('POLYGON', srid=3857, spatial_index=True),
        nullable=False
    )
    # center of the square
    center = Column(
        'center',
        Geometry('POINT', srid=3857, spatial_index=True),
        nullable=False
    )
    # GEOJSON of points contained in the area
    data = Column(
        'data',
        JSON,
        nullable=True
    )
    __table_args__ = (
        UniqueConstraint('aoi', 'center', name='uix_aoi_center'),
    )

    def __init__(self, center):
        from src.spatial import spatialOps
        self.center = center
        self.aoi = spatialOps.shape_aoi(self.center)
        self.data = None

    def __repr__(self):
        return 'Area POLYGON: {aoi!r}'.format(
            aoi=repr(self.aoi)
        )

    def __str__(self):
        return 'Area POLYGON: {aoi!s} with center {center!s}'.format(
            aoi=str(self.aoi),
            center=str(self.center)
        )

    @classmethod
    def store_area(cls, geometry, xco2):
        """
        Given a geometry of a stored point, it adds this point to an existing Area
        of Interest or stores a new AoI with center the given geoemtry.

        :param str geometry: a EWKT string for a geometry
        :param float xco2: a float for xco2 datum
        :return areasAlgorithm:
        """
        from src.areasops import areasOps
        aoi = areasOps.get_aoi_that_contains_(geometry)
        if aoi.check is True:
            # add the point to the existing aoi
            try:
                aoi = areasOps.update_aoi_geojson(geometry, aoi.row, xco2)
            except Exception as e:
                raise e
        elif aoi.check is False:
            # create aoi with center geometry and new geojson, return it
            try:
                aoi = areasOps.store_new_aoi(geometry)
            except Exception as e:
                raise e
        else:
            raise ValueError('get_aoi_that_contains_(geometry) returned a wrong value '
                             'for key \'check\'. It can be only True or False')

        return aoi

    @property
    def named_tuple(self):
        from collections import namedtuple
        AreasNamed = namedtuple('AreasNamed', ['id', 'aoi', 'center', 'data'])
        return AreasNamed(
            id=self.id,
            aoi=self.aoi,
            center=self.center,
            data=self.data
        )


if __name__ == '__main__':
    try:
        from src.dbproxy import dbProxy
        dbProxy.create_tables_in_databases(Base)
        print('####################################\n'
              '#Databases and tables created      #\n'
              '#Enter your psql command line and  #\n'
              '#check that databases {} #\n'
              '#and table t_co2, t_areas are present. #\n'
              '####################################\n'.format(DATABASES))
    except Exception as e:
        print('##### ERROR: have you crated the databases ####'
              'and installed the \'postgis\' extension?  ####')
        raise e
